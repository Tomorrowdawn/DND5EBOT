# 自定义指令

从控制台传入的指令请参见`MiraiCP`的通用做法.以下指令均指群聊指令.

指令设计唯一需要保证的就是前缀匹配;即通过特定前缀我们就能确定这条指令该被谁处理.这么做的好处是,无需将指令放到每个处理函数中去(这将造成极大的开销)就能确定指令会被谁处理.至于指令是否正确就是那单个函数的问题了.

TODO:

实现指令注册机(记得引用name)(类似于(void)isreg).

自定义指令非常非常简单.

你只需要提供一个继承自`Command::Registrar<Type>`的类即可.类中必须重写一个纯虚函数`analyze`,并且提供一个静态字符串`name`用于唯一确定你的命令(不区分大小写).这个`name`必须全局唯一.已使用的请参考手册.

`name`会被传递给专门的命令解析程序,你需要保证这个字符串是你的命令开头,并且不与其他命令冲突.匹配规则遵循"最长前缀匹配".也即如果有两个`name`分别为`r,rie`,那么程序会先试图匹配`rie`.如果失配了才会匹配`r`.由于`rc,rp`等指令被内置在`r`大类下,所以你可以"重载"这些指令(当然最好不要这么做).

附:某种程度上,你可以将这里的指令与命令行类比起来.name唯一指定了一个"程序",每个开发者管理属于自己的程序,无法干涉其他指令类.譬如,如果你想增加一条`r sth`指令,只能使用`r_sth`等方式来实现.或者提issue.

> 这里涉及到一个更复杂的问题,就是前缀编码重复问题.然而在本项目里面没必要花大量精力管理这个问题,只要保证设计时不犯错即可.

`analyze`是你的分析函数,返回一个结果字符串(也就是输出字符串.例如`r2d10=5+5=10`这个字符串本身就是结果).这个字符串会被原封不动地输出,所以请好好美化.

若分析失败,则抛出异常.这个时候程序将抛出异常并显示命令错误,此异常消息请仔细描述错误原因.

你不需要修改其他任何代码(这里面用到了一些"魔术",可以参考源代码[doge]),编译,然后运行即可.