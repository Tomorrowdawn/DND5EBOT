# 架构总览

本机器人由如下几个部分组成:


1. 输入预处理
2. 指令解析程序
3. 记账
4. 计算核心
5. 输出程序

它很像一个计算机.

# 预处理

根据某些规则抓取QQ消息. 最常用的办法是侦测英文句点`.`,其他消息则忽略.此外,命令将被全大写转换。

预处理可以用来让机器人代为执行某些操作,例如检测群聊违禁词等,但超出了本机器人的范围.

# 指令解析程序

支持指令重命名(将多个简单指令浓缩为一条复杂指令执行). 不支持完全自定义,因为这样做需要改动的部分太多.

## 掷骰

最基本的指令是掷骰指令.也就是`D100`等形式的指令.这个指令创建一个具体的骰子对象.

在此基础上,根据骰值的处理方式,又有掷骰前指令和掷骰后指令.掷骰前指令,即骰子出目前能够知道的信息并据此下达指令.优势,劣势都属于此类.

掷骰后指令,即当骰子出目后才能确定的指令,例如预言骰,幸运等.

显然,如果一条指令只有掷骰前指令,那么这条指令是可以完全自动化完成的.若含有掷骰后指令,则无法自动完成.可以通过条件判断的方法机械化执行,但是跑团不是流水作业,人的标准往往难以通过`if`语句判明.

无论含有什么指令,最终,完整的掷骰指令将产生一个骰子的出目.一般来说,掷骰指令由`r`开头,因此下面我们省略这个字母.

以下是基本的掷骰前指令合集(所有指令不区分大小写):

|指令|含义|示范|
|:-:|:-:|:-:|
|`D num`|生成一个num面的`Dice`对象.num是自然数|D100,d 20|
|`[num] Dice`|创建num个同样的Dice对象<br>独立投掷生成一个Points对象.num默认为1|2D100|
|`num#Dice`|投掷num次Dice,每次之间互不干扰,<br>生成多个独立的Points对象|r3#d20|
|`Points k num`|从Points对象中选取最高的num个<br>num必须小于等于Points数目|r 3D100k2|
|`Points l num`|从Points对象中选取最低的num个<br>num必须小于等于Points数目|r 3D100l2|
|`Points gep point`|过滤出Points中大于等于point的|r 3d20 gep 10|
|`count Points`|计算Points的个数|.r count 3d20 gep 10|

这里涉及到两个对象.一个是`Dice`,一个是`Points`. `Points`是`Dice`投掷后产生的,基本上可以看作出目.`3d100`会产生一个`Points`,其中储存了三个出目;`3#d100`会产生三个`Points`,每个储存了一个出目,这就是主要区别.

`Dice`与`Dice`之间是不能做运算的,但是`Points`却可以.一旦`Points`之间发生运算,譬如`P1+P2`,它们将先自加,然后求和,返回一个数字.

基本上,掷骰环节就是一些数字的取用.

## 内置命令

请参考其他各节中列出的指令.

## 自定义命令

使用`using new_name = instrutions`来自定义新命令.自定义命令会在预处理阶段被解析成内置命令。

### 暗骰捏

由于腾讯的机器人检测以及封锁政策,支持暗骰会让机器人变得很危险;所以不原生支持.

# 记账

## 名字

好吧,没有什么比名字更重要了.不过要注意的是,我们的玩家PL的身份与QQ号唯一绑定,在任何群通用.昵称是可以随意变化的;不过不能与群内人名冲突,也不能与已有关键字冲突.简而言之,(群名,昵称)二元组唯一确定一个QQ号.

## 人物卡

> 使用`.create character`来新建一张人物卡

DND人物卡,包括名字,HP,AC,法术环位,移动速度,种族,职业,六大属性,属性应用,专长以及装备.

需要说明的是,只有HP,AC,法术环位,属性值及其应用是被原生支持管理的.也就是说,譬如`HP`降低至0时机器人将提醒你陷入濒死.专长,种族,职业等只是单纯地作为记录存在.

移动速度是你的初始移动速度而非实时移动速度.我们也提供实时移动速度,但并不保证总是正确的(尤其是当你通过施法改变速度,而这个法术未录入时).

> 维持这些高度自由化的东西对于机器人是极大的累赘(尤其是它们并非频繁使用时).所以不支持.

COC人物卡 可能支持

自定义规则人物卡

实际上人物卡就是提供一系列属性然后将其记录. 在这一层面上,可以认为人物卡是一个数据库中的一张表的一个条目. 预计将支持类Mysql语法的人物卡录入.

不过管理上肯定不会用到数据库,因为人物卡是涉及大量修改的项目而不是大量查询的项目,不如内置在系统里.

## 位置

位置可能支持二维直角坐标以及简单的直线移动.但这一项并不一定会支持,就算支持,也不一定保证足够好用.

## NPC

支持批量管理NPC是一个现代DND游戏系统必备的素养。NPC与PC有一点不同在于，DM对于NPC是绝对掌控的，意味着我们的指令设计可以更加激进一些，只要方便DM就是好指令。NPC有专门的管理指令，以`.npc`开头，具体查看指令表。

# 计算核心

## 检验系统

`.rc`提供标准检定.`.rc skill/ability`进行属性值检定,将生成一个属性值检定结果.

`.rb/rp`提供优势/劣势检定.

一般来说,`DC`是`DM`秘密设置的,所以这里不会出现`DC`.

此时依然可以批量检定,如`r2#c Stealth`.

从原理上讲,`c skill`会被替换成`d20+modifier`的形式,所以在检定后面添上任何合法的掷骰式都是可以的.

同理`rb skill`会被展开成`2d20k1`;这意味着你不能通过`rb skill+d5`来表示`2(d20+d5)k1`.这种时候请直接使用基本的掷骰语法.

`.rs`提供豁免检定。特别地，`.rbs,rps`提供优劣势的豁免检定。这些简写你可以直接将其拆分为`.r b s`(实际上程序也是这么做的)来识读。基本上，掷骰指令都是可以随便拆分（在合法的基础上）的；然而一些固定指令，例如`set/modify`就不允许随便乱用了。

## 除法

一律向下取整.

## 账目修改

`.modify item num`用于将账目数据调整为`num`。 

`.set item num`用于将账目初始化为`num`。说穿了，`.modify speed 30`将把速度调整为`30/初始`,而`.set`将设置为`30/30`。

> 小心使用set命令！它会导致原数据丢失

更进一步，`modify`支持表达式，例如`.modifty hp+D5`,但是`set`仅能使用确切的数字。

`set`与`modify`都支持批量修改。

语法为`.modify/set item1 num1;item2 num2;.....`注意，一旦超过一个项目，最后就必须带上分号。

`modify`具体的表达式展开是这样的:

$$
\begin{aligned}
&\mathrm{MOD\rightarrow modify \, FisrtEXP}\\
&\mathrm{FirstEXP\rightarrow name\, specialop \, DICE\, INTER}\\
&\mathrm{INTER\rightarrow \varepsilon \mid ;EXP}\\
&\mathrm{EXP\rightarrow name\, specialop \, DICE\,;EXP \mid \varepsilon}\\
&\mathrm{specialop\rightarrow +\mid -\mid *\mid /\mid \varepsilon}
\end{aligned}
$$

必须使用`specialop`以避免与`DICE`里面的`op`重名导致移进规约冲突。

如果你需要对特定的PC进行操作，请使用`.modify/set to PC item num;...`如果`PC`名字没有出现过，将报错。

有时我们会遇到AOE效果，导致需要批量处理多个PC。这时，我们不通过繁琐的`modify`来解决，而是把这个问题交给玩家。有两种办法，一种是玩家们自主使用`modify`。不过我们更推荐下面这种更酷的方案:被动声明。

### 被动声明

一个法师向人群中丢了一个火球术，然后他向群聊中键入了`.fireball`

机器人告诉他:`扣除一个三阶法术位，你还剩下...法术位`。并且机器人骰了一个`8d6=30`。

那么有许多玩家都受到了火球术的影响，可是他们的豁免检定都不一样，这该怎么处理呢？

答案是使用`.pass`语句

`.pass effect_num DICE`

其中,`effect_num`是一个机器人返回的数字，唯一标记了一个效应。

机器人会计算这个`DICE`掷骰表达式(形如`rd100`)，并储存其结果。直到DM使用`.setx`语句(或者在一定时间后被清除，防止恶意攻击)

`.setx effect_num DC effect`

`effect`描述了此效应会产生的结果。其内容如同`modify`语句。例如`.setx 1 18 hp-5`

更广泛地，我们可以使用`.cast sth`的方法来获取一个`effect_num`，以完成某种批量修改（可以自定义）。

总结下来，我们需要一个命名表（查询用），人物卡表（大量修改）以及一些定时缓存。
